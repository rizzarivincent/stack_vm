getc        // Grab char from user                  [n]
ip          // Push current IP on stack             [n, ip]
swap        // Swap n and ip                        [ip, n]
jmp .Fib    // Jump to the fibonacci function       [ip, n]
putc

.Fib:
push 1      // Push 1                               [ip, n, 1]
geq         // Set cond flag to (1 >= n)            [ip, n, 1]
pop         // Pop 1 off the stack                  [ip, n]
br .Fib.01  // Branch if cond flag is true          [ip, n]
push 0      // Push 0                               [ip, n, 0]
push 1      // Push 1                               [ip, n, 0, 1]
.Fib.loop:
dup         // Duplicate 1                          [ip, n, 0, 1, 1]      [ip, n-1, 1, 1, 1]
swap3       // Swap 0 and 1                         [ip, n, 1, 1, 0]      [ip, n-1, 1, 1, 1]
add         // Add 0 and 1                          [ip, n, 1, 1]         [ip, n-1, 1, 2]
swap3       // Swap n to last                       [ip, 1, 1, n]         [ip, 2, 1, n-1]
dup         // Duplicate n                          [ip, 1, 1, n, n]      [ip, 2, 1, n-1, n-1]
push 2      // Push 2                               [ip, 1, 1, n, n, 2]   [ip, 2, 1, n-1, n-1, 2]
swap        // Swap n and 2                         [ip, 1, 1, n, 2, n]   [ip, 2, 1, n-1, 2, n-1]
sub         // Subtract 2 from n                    [ip, 1, 1, n, n-2]    [ip, 2, 1, n-1, n-3]
push 0      // Push 0                               [ip, 1, 1, n, n-2, 0] [ip, 2, 1, n-1, n-3, 0]
lt          // Set cond flag to (0 < n-2)           [ip, 1, 1, n, n-2, 0] [ip, 2, 1, n-1, n-3, 0]
pop         // Pop 0                                [ip, 1, 1, n, n-2]    [ip, 2, 1, n-1, n-3]
pop         // Pop n-2                              [ip, 1, 1, n]         [ip, 2, 1, n-1]
br .Fib.end // Jump to end code                     [ip, 1, 1, n]         [ip, 2, 1, n-1]
push 1                                              [ip, 1, 1, n, 1]      [ip, 2, 1, n-1, 1]
swap                                                [ip, 1, 1, 1, n]      [ip, 2, 1, 1, n-1]
sub                                                 [ip, 1, 1, n-1]       [ip, 2, 1, n-2]
swap3       // Swap 1 and n                         [ip, n-1, 1, 1]       [ip, n-2, 1, 2]
jmp .Fib.loop   // Jumps to top of loop             [ip, n-1, 1, 1]       [ip, n-2, 1, 2]

.Fib.end:
pop         // Pops n off the stack
swap        // Swaps 1 and 1
pop         // Pops 1 off the stack
swap        // Swaps 1 and ip
jmp         // Returns

.Fib.01:
swap            // Swaps n and ip                       [n, ip]
jmp             // Jumps to ip                          [n]